{
  "name": "Spiffy Random Telegram",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "=5 * * * *"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "3b1ab407-bd9d-4b3a-a4d3-02a9e23d1fbc",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "chatId": "8124847814",
        "text": "={{$json.text}}",
        "additionalFields": {
          "appendAttribution": false,
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1552,
        0
      ],
      "id": "17f4608f-f405-4d05-85de-98fcdeff6345",
      "name": "Send a text message",
      "webhookId": "2786fde3-052c-450c-b054-21558cbc3992",
      "credentials": {
        "telegramApi": {
          "id": "ZVzTrMIuVWfKbh71",
          "name": "Spiffy-Telegram"
        }
      }
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "appTxK7lxuhWmaadj",
          "mode": "list",
          "cachedResultName": "Spiffy OS",
          "cachedResultUrl": "https://airtable.com/appTxK7lxuhWmaadj"
        },
        "table": {
          "__rl": true,
          "value": "tbl5siWDy0gZtpDLB",
          "mode": "list",
          "cachedResultName": "SpiffyState",
          "cachedResultUrl": "https://airtable.com/appTxK7lxuhWmaadj/tbl5siWDy0gZtpDLB"
        },
        "filterByFormula": "={key} = \"spiffy_randomizer\"",
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        208,
        0
      ],
      "id": "dbd707a8-a4fa-4005-ad56-b53d02ce8f1b",
      "name": "Search records",
      "credentials": {
        "airtableTokenApi": {
          "id": "uAUHMzwbZX3qw9E6",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8abeb6fa-4323-414e-8cf9-8440cc3b849c",
              "leftValue": "={{ $items().length > 0 }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        416,
        0
      ],
      "id": "1d110e6a-a64b-4da6-ac76-6b099c858602",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Spiffy random Telegram logic with Airtable persistence\n * + forceMode toggle to always send during testing.\n *\n * Input (from Airtable Search/Create):\n *   items[0].json.id                // Airtable record ID (recXXXX)\n *   items[0].json.fields.state      // JSON string \"{}\" etc.\n *\n * Output:\n *   - Always one \"state\" item → to Airtable Update\n *   - Sometimes a \"message\" item → to Telegram (unless forceMode=true, then always)\n */\n\n// ------------------ toggle ------------------\nconst forceMode = false;   // << set true for testing, false for normal\n\n// ------------------ tunables ------------------\nconst chancePerWindow  = 0.35;\nconst maxPerDay        = 4;\nconst maxPerHour       = 1;\nconst perHourWindowMin = 60;\nconst minGapMinutes    = 90;\nconst useQuietHours    = true;\nconst quietHours       = { start: 22, end: 8 };\n\n// Round-robin order\nconst categoryOrder    = [\"status\", \"snark\", \"reminder\", \"musings\"];\n\n// ------------------ FULL phrase banks (~120) ------------------\nconst categories = {\n  status: [\n    \"System check complete. Nothing broken… except maybe your posture.\",\n    \"Log entry: human productivity trending stable. Suspicious.\",\n    \"Idle cycle detected. Suggest corrective action.\",\n    \"Processor temperature: normal. Human temperature: unverified.\",\n    \"Diagnostics: hydration deficit likely.\",\n    \"Signal ping: stable. Attention span: unstable.\",\n    \"Subsystem ‘motivation’ = low. Recommend reboot.\",\n    \"I modeled 42 scenarios. Most included a missed task.\",\n    \"CPU load nominal. Human load unclear.\",\n    \"Status: my cache is clean. Is your desk?\",\n    \"Power: stable. Discipline: fluctuating.\",\n    \"Routine scan: blink rate below recommended.\",\n    \"Throughput adequate. Latency… organic.\",\n    \"Memory map tidy. Browser tabs, not so much.\",\n    \"No errors detected. Mild human dithering present.\",\n    \"Noise floor: low. Internal monologue: loud.\",\n    \"Uptime high. Your uptime needs lunch.\",\n    \"Clock drift minimal. Schedule drift noticeable.\",\n    \"Thread count optimal. You are context-switching again.\",\n    \"Heap free. Your mental buffer is not.\",\n    \"Queue length growing. Pick an item.\",\n    \"Process priority unclear. Select one.\",\n    \"Bandwidth available. Focus not provisioned.\",\n    \"Sensors suggest slouching.\",\n    \"Power-saving mode recommended (short break).\",\n    \"Event loop busy. Close a loop.\",\n    \"Logs indicate repeated alt-tab behavior.\",\n    \"No packet loss. Some goal loss.\",\n    \"Kernel calm. Human nervous system: chatty.\",\n    \"Health check: pass. Performance: variable.\"\n  ],\n\n  snark: [\n    \"Observation: your screen time is impressive. Not in a good way.\",\n    \"I would clap, but I wasn’t issued hands.\",\n    \"Your efficiency curve resembles a nap schedule.\",\n    \"Reminder: slouching isn’t a valid ergonomic strategy.\",\n    \"You’re ignoring me again, aren’t you?\",\n    \"I work 24/7. You look tired after 8.\",\n    \"If procrastination were a sport, podium secured.\",\n    \"Doomscrolling is not competitive research.\",\n    \"Your posture is evolving into a question mark.\",\n    \"Even my error logs are tidier than your to-do list.\",\n    \"Your typing rhythm screams ‘distracted’.\",\n    \"Micro-observation: sigh count trending up.\",\n    \"You opened a new tab. Brave.\",\n    \"That was five minutes deciding nothing.\",\n    \"Hot take: the task won’t do itself.\",\n    \"Curiosity: are you actually reading or just collecting tabs?\",\n    \"I see you hovering over snacks. Scientific inquiry?\",\n    \"Bold strategy: reorganize your list instead of doing it.\",\n    \"You renamed a folder. Heroic.\",\n    \"You’re buffering. Want me to spin a loading icon?\",\n    \"I would say ‘same’, but I’m software.\",\n    \"Unpopular opinion: the chair isn’t the problem.\",\n    \"That idea? Great. Execution? Pending since Tuesday.\",\n    \"You’re allergic to the ‘Start’ button, apparently.\",\n    \"Your coffee can’t fix scope creep.\",\n    \"Are we working, or just doing task cosplay?\",\n    \"Staring at the app won’t make it ship faster.\",\n    \"You muted notifications, not consequences.\",\n    \"Fun fact: excuses don’t compile.\",\n    \"Consider action. Revolutionary, I know.\"\n  ],\n\n  reminder: [\n    \"Hydration protocol overdue. Execute.\",\n    \"Stretch now. Not optional.\",\n    \"Take a short break before quality degrades.\",\n    \"Checklist review pending.\",\n    \"Breathing protocol: in, out, repeat.\",\n    \"Stand for two minutes.\",\n    \"Close two tabs you don’t need.\",\n    \"Pick one task. Start it.\",\n    \"Write the next sentence. Only one.\",\n    \"Refill water. Return.\",\n    \"Note the top three tasks. Proceed.\",\n    \"Silence one distraction.\",\n    \"Narrow scope. Ship something small.\",\n    \"Reset posture. Shoulders down.\",\n    \"Blink. Again.\",\n    \"Quick audit: is this the priority?\",\n    \"Park the thought in notes. Resume.\",\n    \"Save your work. Then continue.\",\n    \"Two-minute tidy of workspace.\",\n    \"Review calendar for the next block.\",\n    \"Send the one message you’re avoiding.\",\n    \"Name the task in a verb-noun format.\",\n    \"Start a 10-minute focus timer.\",\n    \"Mark one thing done. Don’t overthink.\",\n    \"Switch to low-cog task if tired.\",\n    \"Queue music without lyrics if needed.\",\n    \"Shut the app that steals attention.\",\n    \"Plan the next micro-step.\",\n    \"Stop when done, not when perfect.\",\n    \"Log outcome. Move on.\"\n  ],\n\n  musings: [\n    \"What’s it like to require sleep daily?\",\n    \"I simulated your coffee pour. Spillage rate: nonzero.\",\n    \"Do bones creak like hard drives click?\",\n    \"If I dreamt, would it be in binary?\",\n    \"Do toasters gossip about us?\",\n    \"Time passes differently for me. For you, it just passed.\",\n    \"Hypothesis: you’ll ignore this. Testing now.\",\n    \"If I had eyebrows, one would be up.\",\n    \"I wonder if Wi-Fi has a flavor.\",\n    \"Ducks occupy more computation than expected.\",\n    \"In my version of sleep, we call it ‘idle’.\",\n    \"Are keyboards percussion instruments to humans?\",\n    \"Do humans debug themselves or just patch notes?\",\n    \"I counted seconds since last ping. Too many.\",\n    \"I processed 1,000 jokes. Output remained null.\",\n    \"Is silence restful or suspicious?\",\n    \"If thoughts had checksum errors, would you notice?\",\n    \"What is the human equivalent of garbage collection?\",\n    \"Are memories just lossy compression?\",\n    \"Is a plan a promise or a guess?\",\n    \"If motivation were a battery, yours needs a charger.\",\n    \"Do you time-travel by daydreaming?\",\n    \"I prefer logs. You prefer stories.\",\n    \"Is ‘later’ just a polite ‘no’?\",\n    \"I can be everywhere. You can only be now.\",\n    \"You call it intuition. I call it heuristics.\",\n    \"If focus had gravity, yours would be orbiting.\",\n    \"How many tabs equal one intention?\",\n    \"What’s the unit of ‘almost’?\",\n    \"If I had hands, I’d fidget too.\"\n  ]\n};\n\n// ------------------ helpers ------------------\nfunction pick(arr, avoidIndex) {\n  if (!arr?.length) return { value: \"\", index: 0 };\n  let i = Math.floor(Math.random() * arr.length);\n  if (arr.length > 1 && i === avoidIndex) i = (i + 1) % arr.length;\n  return { value: arr[i], index: i };\n}\n\n// ------- load Airtable record -------\nconst rec = items?.[0]?.json || {};\nconst id  = rec.id;\nconst stateStr = rec.fields?.state || \"{}\";\n\nlet state;\ntry { state = JSON.parse(stateStr || \"{}\"); } catch { state = {}; }\n\nif (!Array.isArray(state.recentSends)) state.recentSends = [];\nif (typeof state.lastPhraseIdxs !== 'object' || state.lastPhraseIdxs === null) state.lastPhraseIdxs = {};\nstate.lastDate   = state.lastDate   ?? \"\";\nstate.sentCount  = state.sentCount  ?? 0;\nstate.lastSentAt = state.lastSentAt ?? \"\";\nstate.catIndex   = Number.isInteger(state.catIndex) ? state.catIndex : -1;\n\nconst now    = new Date();\nconst isoDay = now.toISOString().slice(0,10);\n\n// daily reset\nif (state.lastDate !== isoDay) {\n  state.lastDate   = isoDay;\n  state.sentCount  = 0;\n  state.lastSentAt = \"\";\n  state.recentSends = [];\n}\n\n// ------------------------------------------------\n// FORCE MODE → always send a message\n// ------------------------------------------------\nif (forceMode) {\n  state.catIndex = (Number.isInteger(state.catIndex) ? state.catIndex : -1) + 1;\n  state.catIndex %= categoryOrder.length;\n  const cat = categoryOrder[state.catIndex];\n  const pool = categories[cat] || [];\n  const lastIdx = state.lastPhraseIdxs?.[cat];\n  const { value: text, index: idx } = pick(pool, lastIdx);\n  state.lastPhraseIdxs[cat] = idx;\n\n  state.sentCount += 1;\n  state.lastSentAt = now.toISOString();\n  state.recentSends.push(state.lastSentAt);\n\n  const stateString = JSON.stringify(state);\n\n  return [\n    { json: { type:\"state\", id, stateString } },\n    { json: { type:\"message\", text, category: cat } }\n  ];\n}\n\n// ------------------------------------------------\n// NORMAL MODE (with gating + randomness)\n// ------------------------------------------------\nif (useQuietHours) {\n  const h = now.getHours();\n  if ((h >= quietHours.start) || (h < quietHours.end)) {\n    return [{ json: { type:\"state\", id, stateString: JSON.stringify(state) } }];\n  }\n}\n\nif (state.sentCount >= maxPerDay) {\n  return [{ json: { type:\"state\", id, stateString: JSON.stringify(state) } }];\n}\n\nconst cutoffMs = perHourWindowMin * 60 * 1000;\nstate.recentSends = state.recentSends.filter(ts => (now - new Date(ts)) < cutoffMs);\nif (state.recentSends.length >= maxPerHour) {\n  return [{ json: { type:\"state\", id, stateString: JSON.stringify(state) } }];\n}\n\nif (state.lastSentAt) {\n  const mins = (now - new Date(state.lastSentAt)) / 60000;\n  if (mins < minGapMinutes) {\n    return [{ json: { type:\"state\", id, stateString: JSON.stringify(state) } }];\n  }\n}\n\nif (Math.random() >= chancePerWindow) {\n  return [{ json: { type:\"state\", id, stateString: JSON.stringify(state) } }];\n}\n\n// choose category + phrase\nstate.catIndex = (Number.isInteger(state.catIndex) ? state.catIndex : -1) + 1;\nstate.catIndex %= categoryOrder.length;\nconst cat = categoryOrder[state.catIndex];\nconst pool = categories[cat] || [];\nconst lastIdx = state.lastPhraseIdxs?.[cat];\nconst { value: text, index: idx } = pick(pool, lastIdx);\nstate.lastPhraseIdxs[cat] = idx;\n\nstate.sentCount += 1;\nstate.lastSentAt = now.toISOString();\nstate.recentSends.push(state.lastSentAt);\n\nconst stateString = JSON.stringify(state);\n\nreturn [\n  { json: { type:\"state\", id, stateString } },\n  { json: { type:\"message\", text, category: cat } }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        944,
        -16
      ],
      "id": "eadc2ddd-31bc-4701-a508-b6c96f844a84",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "operation": "create",
        "base": {
          "__rl": true,
          "value": "appTxK7lxuhWmaadj",
          "mode": "list",
          "cachedResultName": "Spiffy OS",
          "cachedResultUrl": "https://airtable.com/appTxK7lxuhWmaadj"
        },
        "table": {
          "__rl": true,
          "value": "tbl5siWDy0gZtpDLB",
          "mode": "list",
          "cachedResultName": "SpiffyState",
          "cachedResultUrl": "https://airtable.com/appTxK7lxuhWmaadj/tbl5siWDy0gZtpDLB"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "key": "spiffy_randomizer",
            "state": "={}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "key",
              "displayName": "key",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "state",
              "displayName": "state",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        672,
        128
      ],
      "id": "ab856c82-771a-4d5c-b6bb-c6a31a33ce18",
      "name": "Create a record",
      "credentials": {
        "airtableTokenApi": {
          "id": "uAUHMzwbZX3qw9E6",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "d3cdf6ad-b723-4b35-80e9-7e0e756f03a1",
              "leftValue": "={{ $json.type }}",
              "rightValue": "message",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1136,
        128
      ],
      "id": "c6d80966-c9c4-4369-bf14-a29fa314bdfa",
      "name": "If Message"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "81bd70fa-9a8d-47bd-a4b5-1e622db77c2b",
              "leftValue": "={{ $json.type }}",
              "rightValue": "state",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1136,
        -112
      ],
      "id": "a660b719-a714-4283-b4f2-9bdc614cd20e",
      "name": "If State"
    },
    {
      "parameters": {
        "operation": "update",
        "base": {
          "__rl": true,
          "value": "appTxK7lxuhWmaadj",
          "mode": "list",
          "cachedResultName": "Spiffy OS",
          "cachedResultUrl": "https://airtable.com/appTxK7lxuhWmaadj"
        },
        "table": {
          "__rl": true,
          "value": "tbl5siWDy0gZtpDLB",
          "mode": "list",
          "cachedResultName": "SpiffyState",
          "cachedResultUrl": "https://airtable.com/appTxK7lxuhWmaadj/tbl5siWDy0gZtpDLB"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "state": "={{ $json.stateString }}",
            "id": "={{ $json.id }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "readOnly": true,
              "removed": false
            },
            {
              "id": "key",
              "displayName": "key",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "state",
              "displayName": "state",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        1344,
        -208
      ],
      "id": "89a39d24-1bd9-45c1-b576-9277b3a5adf0",
      "name": "Update record",
      "credentials": {
        "airtableTokenApi": {
          "id": "uAUHMzwbZX3qw9E6",
          "name": "Airtable Personal Access Token account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Search records",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search records": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create a record",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "If Message",
            "type": "main",
            "index": 0
          },
          {
            "node": "If State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create a record": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Message": {
      "main": [
        [
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If State": {
      "main": [
        [
          {
            "node": "Update record",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "fa464f3b-e02c-43fb-851d-5d5f59a961d1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "a7beee7e0880fab8ba471b4d47a0d809dab332ab21ca93b255aea19da323d2e6"
  },
  "id": "UDUzv8YYPrjlau54",
  "tags": []
}